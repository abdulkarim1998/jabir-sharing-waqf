// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: projects.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateProject = `-- name: CreateProject :one
INSERT INTO projects (
    title, description, value, address, organization_id
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, title, description, value, is_active, is_complete, address, organization_id, created_date, modified_date
`

type CreateProjectParams struct {
	Title          string         `json:"title"`
	Description    string         `json:"description"`
	Value          pgtype.Numeric `json:"value"`
	Address        *string        `json:"address"`
	OrganizationID pgtype.UUID    `json:"organization_id"`
}

func (q *Queries) CreateProject(ctx context.Context, arg *CreateProjectParams) (*Project, error) {
	row := q.db.QueryRow(ctx, CreateProject,
		arg.Title,
		arg.Description,
		arg.Value,
		arg.Address,
		arg.OrganizationID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Value,
		&i.IsActive,
		&i.IsComplete,
		&i.Address,
		&i.OrganizationID,
		&i.CreatedDate,
		&i.ModifiedDate,
	)
	return &i, err
}

const DeleteProject = `-- name: DeleteProject :exec
UPDATE projects SET 
    is_active = false,
    modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteProject, id)
	return err
}

const GetProjectByID = `-- name: GetProjectByID :one
SELECT id, title, description, value, is_active, is_complete, address, organization_id, created_date, modified_date FROM projects WHERE id = $1 AND is_active = true LIMIT 1
`

func (q *Queries) GetProjectByID(ctx context.Context, id uuid.UUID) (*Project, error) {
	row := q.db.QueryRow(ctx, GetProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Value,
		&i.IsActive,
		&i.IsComplete,
		&i.Address,
		&i.OrganizationID,
		&i.CreatedDate,
		&i.ModifiedDate,
	)
	return &i, err
}

const GetProjectCountByOrganizationID = `-- name: GetProjectCountByOrganizationID :one
SELECT COUNT(*) as project_count
FROM projects 
WHERE organization_id = $1 AND is_active = true
`

func (q *Queries) GetProjectCountByOrganizationID(ctx context.Context, organizationID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, GetProjectCountByOrganizationID, organizationID)
	var project_count int64
	err := row.Scan(&project_count)
	return project_count, err
}

const GetProjectFinancialStatus = `-- name: GetProjectFinancialStatus :one
SELECT 
    p.id,
    p.title,
    p.value as target_amount,
    COALESCE(SUM(d.amount), 0) as collected_amount,
    COUNT(d.id) as total_donations
FROM projects p
LEFT JOIN donations d ON p.id = d.project_id AND d.payment_status = 'Completed'
WHERE p.id = $1 AND p.is_active = true
GROUP BY p.id, p.title, p.value
`

type GetProjectFinancialStatusRow struct {
	ID              uuid.UUID      `json:"id"`
	Title           string         `json:"title"`
	TargetAmount    pgtype.Numeric `json:"target_amount"`
	CollectedAmount interface{}    `json:"collected_amount"`
	TotalDonations  int64          `json:"total_donations"`
}

func (q *Queries) GetProjectFinancialStatus(ctx context.Context, id uuid.UUID) (*GetProjectFinancialStatusRow, error) {
	row := q.db.QueryRow(ctx, GetProjectFinancialStatus, id)
	var i GetProjectFinancialStatusRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.TargetAmount,
		&i.CollectedAmount,
		&i.TotalDonations,
	)
	return &i, err
}

const GetProjectsByOrganizationID = `-- name: GetProjectsByOrganizationID :many
SELECT id, title, description, value, is_active, is_complete, address, organization_id, created_date, modified_date FROM projects 
WHERE organization_id = $1 AND is_active = true 
ORDER BY created_date DESC
`

func (q *Queries) GetProjectsByOrganizationID(ctx context.Context, organizationID pgtype.UUID) ([]*Project, error) {
	rows, err := q.db.Query(ctx, GetProjectsByOrganizationID, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Value,
			&i.IsActive,
			&i.IsComplete,
			&i.Address,
			&i.OrganizationID,
			&i.CreatedDate,
			&i.ModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListProjects = `-- name: ListProjects :many
SELECT id, title, description, value, is_active, is_complete, address, organization_id, created_date, modified_date FROM projects WHERE is_active = true ORDER BY created_date DESC
`

func (q *Queries) ListProjects(ctx context.Context) ([]*Project, error) {
	rows, err := q.db.Query(ctx, ListProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Value,
			&i.IsActive,
			&i.IsComplete,
			&i.Address,
			&i.OrganizationID,
			&i.CreatedDate,
			&i.ModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateProject = `-- name: UpdateProject :one
UPDATE projects SET
    title = $2,
    description = $3,
    value = $4,
    address = $5,
    is_complete = $6,
    modified_date = NOW()
WHERE id = $1 AND is_active = true
RETURNING id, title, description, value, is_active, is_complete, address, organization_id, created_date, modified_date
`

type UpdateProjectParams struct {
	ID          uuid.UUID      `json:"id"`
	Title       string         `json:"title"`
	Description string         `json:"description"`
	Value       pgtype.Numeric `json:"value"`
	Address     *string        `json:"address"`
	IsComplete  *bool          `json:"is_complete"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg *UpdateProjectParams) (*Project, error) {
	row := q.db.QueryRow(ctx, UpdateProject,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Value,
		arg.Address,
		arg.IsComplete,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Value,
		&i.IsActive,
		&i.IsComplete,
		&i.Address,
		&i.OrganizationID,
		&i.CreatedDate,
		&i.ModifiedDate,
	)
	return &i, err
}
